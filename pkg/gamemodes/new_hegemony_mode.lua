local heg_description = [==[
# 国战简介

《三国杀·国战》是一款可以支持2\~12人(线上版4\~8人)同时参与的桌面卡牌游戏。在游戏中，每名玩家将甄选三国时代中包括魏国、蜀国、吴国、群雄在内的各位名将，组成自己的战斗团队，利用他们珠联璧合的组合技能发起进攻，消灭其他各方势力，赢得最终的胜利。

## 准备游戏

**挑选武将：**

发给每位玩家若干张武将牌，选出两张势力相同的武将牌并背面朝上放置，称为“暗置”（参考段落“明置和暗置”）。（特别的，野心家势力武将仅可以做主将，其副将可以是任意势力武将）

左侧为主将，右侧为副将。（按，此为网杀惯例）

游戏中，每名玩家扮演的角色由两张武将牌组成。

**分发体力牌：**

每位玩家拿取一张体力牌，翻到对应体力上限的一面，放置在武将牌旁边。体力上限为两张武将牌上的完整阴阳鱼的数量之和。两个单独的阴阳鱼可以组成一个完整的阴阳鱼。

注：**当一名角色的两张武将牌第一次均明置时，若其武将牌上有单独的阴阳鱼没有组成1 点体力，则其获得一枚“阴阳鱼”**（参见段落“标记牌”）。例如，司马懿1.5阴阳鱼，张辽2阴阳鱼，合计3.5阴阳鱼，体力上限为3，获得一枚“阴阳鱼”。

## 进行游戏

随机选择一名玩家作为起始玩家。由该玩家开始，按逆时针方向以回合的方式进行。即每名玩家有一个自己的回合，一名玩家的回合结束后， 右边玩家的回合开始，依次轮流进行。

每个玩家的回合可以分为六个阶段：

准备阶段 -> 判定阶段 -> 摸牌阶段 -> 出牌阶段 -> 弃牌阶段 -> 结束阶段

**准备阶段：**

有些技能可以在此阶段发动。你的暗置的武将牌也可于此阶段明置。

**判定阶段：**

若你的面前横置着延时类锦囊，你必须依次对这些延时类锦囊进行判定。若有多张延时类锦囊，先判定最后放置的那张，然后以此类推。

**摸牌阶段：**

你从牌堆顶摸两张牌。（如无特别说明，“摸……张牌”就是从牌堆顶摸牌）

**出牌阶段：**

你可以使用任意张牌，但必须遵守以下两条规则：

1. 每个出牌阶段仅限使用一次【杀】。
2. 任何一名角色面前的判定区里不能放有两张同名的牌。

每使用一张牌，即执行该牌之效果，详见“游戏牌详解”。如无特殊说明，游戏牌在使用后均需置入弃牌堆。

**弃牌阶段：**

在出牌阶段中，不想出或没法出牌时，就进入弃牌阶段。此时检查你的手牌数是否超出你当前的体力值( 你的手牌上限等于你当前的体力值)， 每超出一张，须弃置一张手牌。

**结束阶段：**

有些技能可以在此阶段发动。


## 角色死亡

当一名角色的体力降到0 时，即进入濒死状态，除非该角色在此时使用【酒】，或有角色使用【桃】来挽救该角色，否则该角色死亡。

死亡的角色明置其武将牌，弃置该角色所有牌及其判定区里的牌，然后执行奖惩。

奖惩方式：

1. **已经确定势力的角色杀死相同势力的角色须弃置所有手牌和装备区的牌**；
2. **已经确定势力的角色杀死不同势力的角色，摸等同于该势力人数（包括刚刚杀死的角色）张牌**；
3. 特别地，野心家击杀奖励为摸三张牌。

例：“蜀”势力角色杀死了一名“魏”势力角色，此时还有其他两名“魏”势力角色存活，则该“蜀”势力角色摸三张牌。

注：若被杀死的角色还没有明置武将牌（即没确定势力），则须明置所有武将牌，验明势力。 没有势力的角色（即武将牌没有明置的角色）杀死其他角色没有奖惩。

## 胜负结算

玩家的游戏目标与势力有关：**消灭所有与自己不同势力的角色**。

特殊的：野心家需要消灭所有其他角色。

当全场所有角色均确定势力后, 才可以进行胜利条件的判断:
当全场只剩下一种势力存活时, 该势力的角色获胜( 没有确定势力的角色无法取得游戏胜利, 即使与存活的其他角色为同一势力)。

## 暗将规则

**处于暗置状态的武将牌没有任何武将技能、性别以及势力**。当暗置的武将牌发动技能时，将武将牌明置，然后发动相应的技能。

一般地，**暗置的武将牌只有两个时机可以将武将牌明置：1. 回合开始时；2. 发动武将牌的技能时。** 

例：郭嘉、司马懿等，受到伤害后发动技能时明置武将牌；
马超、黄忠等，使用【杀】指定一名角色为目标后，发动技能并明置武将牌；
孙权、甘宁等，在出牌阶段发动技能时明置武将牌；

（在网杀中，你需要“预亮”某些触发技，即点击技能到“预亮”状态，来让系统在相应的时机询问你是否发动技能亮将，如预亮郭嘉、马超等的遗计、铁骑。不“预亮”的技能不会询问。）

另外，**拥有锁定技的武将，可以在出牌阶段明置。** 例如：有〖咆哮〗的张飞、有〖马术〗的马超。

**全场游戏第一个明置武将的角色获得一枚“先驱”标记（参见段落“标记牌”）。

没有明置武将牌的角色没有性别，任何与性别有关的技能和武器效果均不能对其发动。

有一张武将牌明置时，角色性别与明置的武将牌相同。当一名角色的两张武将牌均亮明后，性别与主将的武将牌相同。

没有明置武将牌的角色没有势力，明置一张武将牌后确定势力：与武将牌左上角所示的势力相同，或成为野心家。野心家用“野心家牌”表示。（参见下一段“野心家规则”）。

野心家规则：

**当一名角色明置武将牌确定势力时，若该势力的角色超过了游戏总玩家数的一半，则他成为野心家**，拿取一张野心家牌表示。若之后仍然有该势力的角色明置武将牌，均视为野心家。**野心家为单独的一种势力**，与其他角色的势力均不同。他（们）需要杀死所有其他角色，成为唯一的存活者。

注意：野心家与野心家之间也是不同势力。

例：

★ 6 人、7 人游戏时，当出现第四名同势力角色时，该角色及之后明置的该势力角色均成为野心家。

★ 8 人、9 人游戏时，当出现第五名同势力角色时，该角色及之后明置的该势力角色均成为野心家。

## 珠联璧合

珠联璧合表示了部分武将之间的特殊联系。一般是夫妻、挚友等，如刘备-关羽，周瑜-小乔。

武将牌中下方的其他武将姓名表示了可以和此武将牌形成珠联璧合的其他武将。

**若你选择的两张武将牌形成珠联璧合，则在第一次两张武将牌均明置时，获得一枚“珠联璧合”**（参见段落“标记牌”）。

## 标记牌

**珠联璧合**：出牌阶段，你可弃一枚“珠联璧合”，摸两张牌；你可弃一枚“珠联璧合”，视为使用【桃】。

**阴阳鱼**：出牌阶段，你可弃一枚“阴阳鱼”，摸一张牌；弃牌阶段开始时，你可弃一枚“阴阳鱼”，此回合手牌上限+2。

**先驱**：出牌阶段，你可弃一枚“先驱”，将手牌摸至4张，观看一名其他角色的一张暗置武将牌。

## 鏖战

当游戏中仅剩4名或更少角色时（7人以下游戏时为3名或更少），若此时全场没有超过一名势力相同的角色，则从一个新的回合开始，游戏进入鏖战模式。

鏖战模式下，所有的【桃】只能当【杀】或【闪】使用或打出，不能用于回复体力。

# 君临天下和势备篇补充规则和术语

## 大小势力 （势备篇）

**大势力**：人数最多且数量不小于2的势力。

**小势力**：若大势力存在，除大势力以外的其他势力。

**大势力角色**：势力为大势力的角色。

**小势力角色**：若大势力角色存在，不为大势力角色的角色。

没有大势力，就不可能有小势力、大势力角色、小势力角色。反之，有大势力，不一定有小势力。

小势力角色还包括未确定势力的角色。即势力为小势力的角色一定是小势力角色，而小势力角色不一定是势力为小势力的角色。

## 合纵 （势备篇）

某些牌上标有“合”标记。

每名角色的出牌阶段限一次，可以选择一项：
1.若你已确定势力，你可以将手牌中有“合”标记的至多三张牌交给与你势力不同的一名角色，摸等量的牌。
2.你可以将手牌中有“合”标记的至多三张牌交给未确定势力的一名角色。

即，出限一、限三张、摸等量。给明将摸牌，给暗将不摸；暗将不能给明将。

## 阵法、围攻、队列、主/副将技 （君临天下·阵）

**阵法技**：在全场存活角色数为4或更多时锁定生效的技能。拥有阵法技的角色可在其准备阶段开始时或出牌阶段发起“阵法召唤”。

**阵法召唤**：由拥有阵法技的角色发起，未确定势力、明置后将会满足此阵法技条件的角色均可明置其一张（满足条件的）武将牌，响应阵法召唤。

**围攻**：一名角色的上家和下家为两名势力相同的角色(且与该角色势力不同)时，该角色被“围攻”，成为“被围攻角色”；该角色的上家和下家成为“围攻角色”；该“围攻角色”和“被围攻角色”处于同一“围攻关系”。

**队列**：连续相邻的若干名(至少2名)势力相同的角色称为同一“队列”。

**主将技**：此武将牌为主将时才能使用的技能。

**副将技**：此武将牌为副武将才能使用的技能。

## 移除 （君临天下·势）

**移除**：将被移除的武将牌置入武将牌堆。被移除武将牌的角色用一张“士兵牌”来代替被移除的武将牌，“士兵牌”的性别、势力与被移除的武将牌相同，但没有技能，该角色没有“士兵牌”所占据的主将/副将。

## 变更 （君临天下·变）

**变更**：（线下）从武将牌堆中连续亮出武将牌，直到亮出一张势力相同的武将牌。将此武将牌作为新的副将（若原先有副将，将副将的原武将牌置入武将牌堆）。每局游戏限一次。

（线上则为从提供的三个同势力武将中选择一个）

## 军令 （君临天下·权）

**军令**：有些技能可以发起军令，发起军令分为（发起者）抽取选择军令和（执行者）询问执行军令。

发起军令的角色随机获得两张军令牌，然后选择其中一张，交给执行军令的角色。

执行军令的角色选择是否执行该“军令”。如果执行，该军令牌的效果生效。

6张军令牌：

军令一：对发起者指定的角色造成1点伤害；

军令二：摸一张牌，然后交给发起者两张牌；

军令三：失去1点体力；

军令四：本回合不能使用或打出手牌且所有非锁定技失效；

军令五：叠置，本回合不能回复体力；

军令六：选择一张手牌和一张装备区里的牌，弃置其余的牌。

## 君主规则 （君临天下）

武将牌上的势力名称为“君”的武将为该势力君主武将。（君刘备、君张角、君孙权、君曹操）

玩家将对应的普通武将设置为主将，在第一个回合开始亮将时，可以亮出主将并替换为对应的君主武将。

（其他时点亮将均不能变身君主武将。）

君主武将牌不可被暗置。君主武将和所有本势力武将均有“珠联璧合”的关系。

君主武将牌明置时，所有与此君主势力相同的野心家角色恢复其原有势力，在君主武将存活时，所有与君主势力相同的角色均不会成为野心家。

某势力的君主死后，其他与君主势力相同的角色均成为野心家。

]==]

-- local hegRule = require("packages.hegemony.pkg.hegemony_standard.skills.hegemony_rule")

local H = require "packages/hegemony/util"

local heg

---@class HegLogic: GameLogic
local HegLogic = {}

function HegLogic:assignRoles()
  local room = self.room
  for _, p in ipairs(room.players) do
    room:setPlayerProperty(p, "role_shown", false)
    p.role = "hidden"
    room:broadcastProperty(p, "role")
  end

  -- for adjustSeats
  room.players[1].role = "lord"
end

function HegLogic:chooseGenerals()
  local room = self.room
  local generalNum = math.max(room.settings.generalNum, 5)
  room:doBroadcastNotify("ShowToast", Fk:translate("#HegInitialNotice"))

  local lord = room:getLord() --[[@as ServerPlayer]]
  room:setCurrent(lord)
  lord.role = "hidden"

  local allKingdoms = {} ---@type string[]
  table.forEach(room.general_pile, function(name)
    table.insertIfNeed(allKingdoms, Fk.generals[name].kingdom) -- 假设不会有只出现在副势力的势力
  end)
  table.removeOne(allKingdoms, "wild") -- 野心家势力不包括
  if #allKingdoms > 4 then
    local kingdoms = table.random(allKingdoms, 4)
    local unused = table.filter(allKingdoms, function(k)
      return not table.contains(kingdoms, k)
    end)
    room:sendLog{
      type = "#KingdomFiltered",
      arg = table.concat(table.map(unused, Util.TranslateMapper), " "),
      arg2 = table.concat(table.map(kingdoms, Util.TranslateMapper), " "),
      toast = true,
    }
    for i = #room.general_pile, 1, -1 do
      local g = Fk.generals[room.general_pile[i]]
      if table.contains(unused, g.kingdom) or table.contains(unused, g.subkingdom) then
        table.remove(room.general_pile, i)
      end
    end
    -- 然后把武将牌堆弄好
    allKingdoms = kingdoms
  end
  table.sort(allKingdoms)
  room:setBanner("all_kingdoms", allKingdoms)

  local players = room.players
  local generals = room:getNGenerals(#players * generalNum) -- Fk:getGeneralsRandomly
  table.shuffle(generals)
  local req = Request:new(players, "AskForGeneral")
  req.timeout = self.room.settings.generalTimeout
  for k, p in ipairs(players) do
    -- local arg = { map = table.map }
    local arg = table.slice(generals, (k - 1) * generalNum + 1, k * generalNum + 1)
    table.sort(arg, function(a, b) return Fk.generals[a].kingdom > Fk.generals[b].kingdom end)

    for idx, _ in ipairs(arg) do
      local g = Fk.generals[arg[idx]]
      local g2 = Fk.generals[arg[idx + 1]]
      if (g.kingdom == g2.kingdom and g.kingdom ~= "wild") or (g.kingdom == "wild" and g2.kingdom ~= "wild") or
        (g.subkingdom ~= nil and g.subkingdom == g2.subkingdom) or g.kingdom == g2.subkingdom or g.subkingdom == g2.kingdom then
          req:setDefaultReply(p, {arg[idx], arg[idx + 1]})
          break
      end
    end

    req:setData(p, {arg, 2, false, true})
  end

  local selected = {}
  for _, p in ipairs(players) do
    local general_ret = req:getResult(p)
    local general, deputy = general_ret[1], general_ret[2]
    room:setPlayerGeneral(p, general, true)
    room:setDeputyGeneral(p, deputy)
    table.insertTableIfNeed(selected, {general, deputy})

    room:setPlayerMark(p, "__heg_general", general)
    room:setPlayerMark(p, "__heg_deputy", deputy)

    room:setPlayerGeneral(p, "anjiang", true)
    room:setDeputyGeneral(p, "anjiang")
  end

  generals = table.filter(generals, function(g) return not table.contains(selected, g) end)
  room:returnToGeneralPile(generals)

  req = Request:new(players, "AskForChoice")
  req.focus_text = "AskForKingdom"
  req.receive_decode = false

  for _, p in ipairs(players) do
    local curGeneral = Fk.generals[p:getMark("__heg_general")]
    local kingdoms = {curGeneral.kingdom, curGeneral.subkingdom}
    curGeneral = Fk.generals[p:getMark("__heg_deputy")]
    if kingdoms[1] == "wild" then
      kingdoms = {curGeneral.kingdom, curGeneral.subkingdom}
      room:setPlayerMark(p, "__heg_wild", 1)
    else
      kingdoms = table.filter(kingdoms, function(k) return curGeneral.kingdom == k or curGeneral.subkingdom == k end)
    end

    if not table.contains(allKingdoms, "wu") and
      (p:getMark("__heg_deputy") == "mouxusheng" or p:getMark("__heg_general") == "mouxusheng") then -- 方便测
        table.insert(kingdoms, "wu")
        table.insert(allKingdoms, "wu")
    end

    req:setData(p, {kingdoms, allKingdoms, "AskForKingdom", "#ChooseHegInitialKingdom"})
    req:setDefaultReply(p, kingdoms[1])
  end

  for _, p in ipairs(players) do
    local kingdomChosen = req:getResult(p)
    room:setPlayerMark(p, "__heg_kingdom", kingdomChosen) -- 变野后变为wild
    room:setPlayerMark(p, "__heg_init_kingdom", kingdomChosen) -- 保存初始势力
    p.default_reply = ""
    -- p.kingdom = kingdomChosen
    --room:notifyProperty(p, p, "kingdom")
  end
end

function HegLogic:broadcastGeneral()
  local room = self.room
  local players = room.players

  for _, p in ipairs(players) do
    assert(p.general ~= "")
    local general = Fk.generals[p:getMark("__heg_general")]
    local deputy = Fk.generals[p:getMark("__heg_deputy")]
    local dmaxHp = deputy.maxHp + deputy.deputyMaxHpAdjustedValue
    local gmaxHp = general.maxHp + general.mainMaxHpAdjustedValue
    p.maxHp = (dmaxHp + gmaxHp) // 2
    -- p.hp = math.floor((deputy.hp + general.hp) / 2)
    p.hp = p.maxHp
    -- p.shield = math.min(general.shield + deputy.shield, 5)
    p.shield = 0
    -- TODO: setup AI here

    room:broadcastProperty(p, "general")
    room:broadcastProperty(p, "deputyGeneral")
    room:broadcastProperty(p, "maxHp")
    room:broadcastProperty(p, "hp")
    room:broadcastProperty(p, "shield")

    p.role = p:getMark("__heg_wild") == 1 and "wild" or p:getMark("__heg_kingdom") -- general.kingdom -- 为了死亡时log有势力提示

    if (dmaxHp + gmaxHp) % 2 == 1 then
      p:setMark("HalfMaxHpLeft", 1)
      p:doNotify("SetPlayerMark", json.encode{ p.id, "HalfMaxHpLeft", 1})
    end
    if general:isCompanionWith(deputy) then
      p:setMark("CompanionEffect", 1)
      p:doNotify("SetPlayerMark", json.encode{ p.id, "CompanionEffect", 1})
    end
  end
end

function HegLogic:prepareDrawPile()
  GameLogic.prepareDrawPile(self)

  local room = self.room
  local allianceCards = table.clone(H.allianceCards)
  local addAllianceMark = function(c)
    for i = #allianceCards, 1, -1 do
      local cc = allianceCards[i]
      if c.name == cc[1] and c.suit == cc[2] and c.number == cc[3] then
        room:setCardMark(c, "@@alliance", 1)
        table.remove(allianceCards, i)
        break
      end
    end
  end
  for _, cid in ipairs(room.draw_pile) do
    addAllianceMark(Fk:getCardById(cid))
  end
  for _, cid in ipairs(room.void) do
    addAllianceMark(Fk:getCardById(cid))
  end
end

local function addHegSkill(player, skill, room)
  player:addFakeSkill(skill)
  local toget = {table.unpack(skill.related_skills)}
  table.insert(toget, skill)
  for _, s in ipairs(toget) do
    if s:isInstanceOf(TriggerSkill) then
      room.logic:addTriggerSkill(s)
    end
  end
end

function HegLogic:attachSkillToPlayers()
  local room = self.room
  for _, p in ipairs(room.alive_players) do
    -- UI
    p:setMark("@seat", "seat#" .. tostring(p.seat))
    p:doNotify("SetPlayerMark", json.encode{ p.id, "@seat", "seat#" .. tostring(p.seat)})

    local general = Fk.generals[p:getMark("__heg_general")]
    local skills = general:getSkillNameList(true)
    local hasRevealSkill = false
    for _, sn in ipairs(skills) do
      local s = Fk.skills[sn]
      if not s:hasTag(Skill.DeputyPlace) then
        addHegSkill(p, s, room)
        if not hasRevealSkill and s:hasTag(Skill.Compulsory) then
          hasRevealSkill = true
        end
      end
    end

    local deputy = Fk.generals[p:getMark("__heg_deputy")]
    if deputy then
      skills = deputy:getSkillNameList(true)
      for _, sn in ipairs(skills) do
        local s = Fk.skills[sn]
        if not s:hasTag(Skill.MainPlace) then
          addHegSkill(p, s, room)
          if not hasRevealSkill and s:hasTag(Skill.Compulsory) then
            hasRevealSkill = true
          end
        end
      end
    end

    if hasRevealSkill then
      p:addFakeSkill("reveal_skill&")
    end
  end

  room:doBroadcastNotify("ShowToast", Fk:translate("#HegInitialNotice"))
end

local heg_getLogic = function()
  local h = GameLogic:subclass("HegLogic")
  for k, v in pairs(HegLogic) do
    h[k] = v
  end
  return h
end

heg = fk.CreateGameMode{
  name = "new_heg_mode",
  minPlayer = 2,
  maxPlayer = 10,
  rule = "heg_rule",
  logic = heg_getLogic,
  main_mode = "heg_mode",
  is_counted = function(self, room)
    return #room.players >= 6
  end,
  whitelist = {
    "hegemony_cards",
    "hegemony_standard",
    "formation",
    "momentum",
    "transformation",
    "power",
    "strategic_advantage",
    "tenyear_heg",
    "overseas_heg",
    "lord_ex",
    "offline_heg",
    "zqdl",

    "lord_cards",
  },
  winner_getter = function(self, victim)
    local room = victim.room
    local alive = table.filter(room.alive_players, function(p)
      return not p.surrendered
    end)
    if #alive == 1 then
      local p = alive[1] ---@type ServerPlayer
      p:revealGeneral(false)
      p:revealGeneral(true)
      return p.role
    end

    local winner -- = alive[1]
    for _, p in ipairs(alive) do
      if p.kingdom ~= "unknown" then
        winner = p
        break
      end
    end
    if not winner then return "" end
    local kingdom = H.getKingdom(winner)
    local i = H.getKingdomPlayersNum(room, true)[kingdom]
    for _, p in ipairs(alive) do
      if not H.compareExpectedKingdomWith(p, winner) then
        return ""
      end
      if p.kingdom == "unknown" then
        i = i + 1
      end
    end
    if i > #room.players // 2 and not H.getHegLord(room, winner) then return "" end
    return kingdom
  end,
  surrender_func = function(self, playedTime)
    local winner
    local kingdomCheck = true
    for _, p in ipairs(Fk:currentRoom().alive_players) do
      -- 场上有未明置的主将时不能投降
      if p.general == "anjiang" then
        kingdomCheck = false
        break
      end
      if p ~= Self then
        if not winner then
          winner = p
        elseif not H.compareKingdomWith(winner, p) then
          kingdomCheck = false
          break
        end
      end
    end
    return { { text = "heg: besieged on all sides", passed = kingdomCheck } }
  end,

  build_draw_pile = function(self)
    local draw, void = GameMode.buildDrawPile(self)

    for i = #draw, 1, -1 do
      local card = Fk:getCardById(draw[i])
      if H.convertCards[card.name] then
        local name = H.convertCards[card.name]
        if table.find(draw, function(c)
          return Fk:getCardById(c).name == name
        end) then
          local id = table.remove(draw, i)
          table.insert(void, id)
        end
      end
    end

    return draw, void
  end,

  reward_punish = function (self, victim, killer)
    local room = victim.room
    if killer then
      if killer.kingdom ~= "unknown" and not killer.dead then
        local times = 1
        if room:getBanner("additional_reward") then
          times = 1 + room:getBanner("additional_reward")
        end
        -- 因为建国，修改奖惩；如果还没建国
        if killer.kingdom == "wild" and killer:getMark("__heg_construct_wild") == 0 and killer:getMark("__heg_join_wild") == 0 then
          killer:drawCards(times * 3, "kill")
        elseif H.compareKingdomWith(killer, victim) and not (room.logic:getCurrentEvent():findParent(GameEvent.Death, true).data.extra_data or {}).ignorePunishment then --朱灵
          killer:throwAllCards("he")
        else
          killer:drawCards(times * (H.getSameKingdomPlayersNum(room, victim) + 1), "kill")
        end
      end
    end
    if string.find(victim.general, "lord") then
      local players = (table.filter(room.players, function(p) return
        (p:getMark("__heg_kingdom") == victim.kingdom or (p.dead and p.kingdom == victim.kingdom)) and p ~= victim and p.kingdom ~= "wild"
      end))
      room:sortByAction(players)
      local function wildChooseKingdom(player, generalName)
        local allKingdoms = room:getBanner("all_kingdoms")
        table.insertTable(allKingdoms, {"unknown", "hidden"})

        local choice
        local all_choices = table.clone(H.wildKingdoms)
        local choices = table.clone(all_choices)
        for _, p in ipairs(room.players) do
          table.removeOne(choices, p.role)
        end
        if player.general == generalName and H.kingdomMapper[generalName] and H.kingdomMapper[generalName] ~= player.role then -- 野心家钦定
          if table.contains(choices, H.kingdomMapper[generalName]) then
            choice = H.kingdomMapper[generalName]
          else
            choice = room:askToChoice(player, {
              choices = choices,
              skill_name = "heg_rule",
              prompt = "#wild-choose",
              cancelable = false,
              all_choices = all_choices,
            })
          end
        elseif table.contains(allKingdoms, player.role) then
          choice = room:askToChoice(player, {
            choices = choices,
            skill_name = "heg_rule",
            prompt = "#wild-choose",
            cancelable = false,
            all_choices = all_choices,
          })
        end
        if choice then
          player.role = choice
          room:setPlayerProperty(player, "role_shown", true)
          room:broadcastProperty(player, "role")
          room:sendLog{
            type = "#WildChooseKingdom",
            from = player.id,
            arg = choice,
            arg2 = "wild",
          }
        end
      end
      for _, p in ipairs(players) do
        local oldKingdom = p.kingdom
        room:setPlayerMark(p, "__heg_kingdom", "wild")
        if oldKingdom ~= "unknown" then
          room:setPlayerProperty(p, "kingdom", "wild")
          if not p.dead then
            wildChooseKingdom(p, p.general)
          end
        end
      end
    end
  end,
  friend_enemy_judge = function (self, targetOne, targetTwo)
    return H.compareExpectedKingdomWith(targetOne, targetTwo)
  end,
}

Fk:loadTranslationTable{
  ["new_heg_mode"] = "国战模式",
  [":new_heg_mode"] = heg_description,
  ["#KingdomFiltered"] = "本局移除 %arg，使用 %arg2 4个势力",
  ["#ChooseHegInitialKingdom"] = "国战规则：选择你的初始势力",
  ["wild"] = "野心家",
  ["heg_rule"] = "国战规则",
  ["revealAll"] = "全部明置",
  ["#EnterBattleRoyalMode"] = "游戏进入 <font color=\"red\"><b>鏖战模式</b></font>，所有的【<font color=\"#3598E8\"><b>桃</b></font>】"..
    "只能当【<font color=\"#3598E8\"><b>杀</b></font>】或【<font color=\"#3598E8\"><b>闪</b></font>】使用或打出，不能用于回复体力",
  ["#EnterBattleRoyalModeLog"] = "游戏进入 <font color=\"#CC3131\"><b>鏖战模式</b></font>",
  ["@[:]BattleRoyalDummy"] = "", -- 额
  ["BattleRoyalMode"] = "鏖战模式",
  [":BattleRoyalMode"] = "所有的【<font color=\"#3598E8\"><b>桃</b></font>】"..
    "只能当【<font color=\"#3598E8\"><b>杀</b></font>】或【<font color=\"#3598E8\"><b>闪</b></font>】使用或打出，不能用于回复体力",
  ["#wild-choose"] = "野心家建国：选择你要成为的势力！",
  ["heg_qin"] = "秦",
  ["heg_qi"] = "齐",
  ["heg_chu"] = "楚",
  ["heg_yan"] = "燕",
  ["heg_zhao"] = "赵",
  ["heg_hanr"] = "韩",
  ["heg_jin"] = "晋", -- 和真的晋是两个势力
  ["heg_han"] = "汉",
  ["heg_xia"] = "夏",
  ["heg_shang"] = "商",
  ["heg_zhou"] = "周",
  ["heg_liang"] = "凉",
  ["#WildChooseKingdom"] = "%from 成为 %arg2 ，选择了势力 %arg",
  ["heg: besieged on all sides"] = "四面楚歌，被同一势力围观",
  ["@@alliance"] = "合",
  ["@@alliance-inhand"] = "合",
  ["@@alliance-inhand-turn"] = "合",
  ["@seat"] = "",
  ["stack"] = "叠置",

  ["#SuccessBuildCountry"] = "%from 成功建立国家，国号 %arg ，队友是 %arg2",
  ["heg_rule_join_country"] = "加入 <b><font color='purple'>%src</font></b> 的阵营 <b><font color='purple'>%arg</font></b>，回复1点体力，将手牌摸至4张",
  ["heg_build_country"] = "拉拢人心，询问其他角色加入 <b><font color='purple'>%arg</font></b>",

  ["#HegInitialNotice"] = "提示：<b><font color='purple'>暴露野心，拉拢人心</font></b><b>已上线</b><br><b><font color='red'>君刘备</font></b>、<b><font color='#8c92ac'>君张角</font></b>、<b><font color='forestgreen'>君孙权</font></b>、<b><font color='royalblue'>君曹操</font></b>均已登场！<br><b><font color='goldenrod'>君主</font></b>必须选择对应普通武将为<b>主将</b>，并在<b>首个回合亮将</b>才能变身",
}

return heg
